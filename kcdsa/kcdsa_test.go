package kcdsa

import (
	"bytes"
	"crypto/rand"
	"encoding/hex"
	"math/big"
	"testing"
)

func testSignAndVerify(t *testing.T, i int, priv *PrivateKey) {
	data := []byte("testing")
	r, s, err := Sign(rand.Reader, priv, bytes.NewReader(data))
	if err != nil {
		t.Errorf("%d: error signing: %s", i, err)
		return
	}

	ok, err := Verify(&priv.PublicKey, bytes.NewReader(data), r, s)
	if err != nil {
		t.Errorf("%d: error verifing: %s", i, err)
		return
	}
	if !ok {
		t.Errorf("%d: Verify failed", i)
	}
}

func testParameterGeneration(t *testing.T, sizes ParameterSizes, L, N int) {
	var priv PrivateKey
	params := &priv.Parameters

	err := GenerateParameters(params, rand.Reader, sizes)
	if err != nil {
		t.Errorf("%d: %s", int(sizes), err)
		return
	}

	if params.P.BitLen() != L {
		t.Errorf("%d: params.BitLen got:%d want:%d", int(sizes), params.P.BitLen(), L)
	}

	if params.Q.BitLen() != N {
		t.Errorf("%d: q.BitLen got:%d want:%d", int(sizes), params.Q.BitLen(), L)
	}

	one := new(big.Int)
	one.SetInt64(1)
	pm1 := new(big.Int).Sub(params.P, one)
	quo, rem := new(big.Int).DivMod(pm1, params.Q, new(big.Int))
	if rem.Sign() != 0 {
		t.Errorf("%d: p-1 mod q != 0", int(sizes))
	}
	x := new(big.Int).Exp(params.G, quo, params.P)
	if x.Cmp(one) == 0 {
		t.Errorf("%d: invalid generator", int(sizes))
	}

	err = GenerateKey(&priv, rand.Reader)
	if err != nil {
		t.Errorf("error generating key: %s", err)
		return
	}

	testSignAndVerify(t, int(sizes), &priv)
}

func TestParameterGeneration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping parameter generation test in short mode")
	}

	testParameterGeneration(t, L2048N224WithSHA224, 2048, 224)
	testParameterGeneration(t, L2048N224WithSHA256, 2048, 224)
	testParameterGeneration(t, L2048N256WithSHA256, 2048, 256)
	testParameterGeneration(t, L3072N256WithSHA256, 3072, 256)
}

func fromHex(s string) *big.Int {
	result, ok := new(big.Int).SetString(s, 16)
	if !ok {
		panic(s)
	}
	return result
}
func fromHexBytes(s string) []byte {
	b, err := hex.DecodeString(s)
	if err != nil {
		panic(s)
	}
	return b
}

func TestSignAndVerify(t *testing.T) {
	priv := PrivateKey{
		PublicKey: PublicKey{
			Parameters: Parameters{
				P:     fromHex("99811DA76C8218A64F16C765831F140AA833095E3D3126DAC600CAAE8BDDC68E364AB88DDD4AFC56BFFADF17E76DA84C515D41B8A291CF536CB7E087060EC6CEEFE80D1B58A33108C35FD13E897B7B88B51BE194BD693DA5754EC008EBC712C96A4A3BC24B67AABFD2FD9DA28FA1F9EC8032A8E96F6B89AC2AC941AB66E83B8E1BEC0DEE9241110003071BE1B028FC29C7DD046E829D43046014D1BF30FDF2C68C4F60CBE42DCC1E83A9A3E0F9E745BADA12BC7629E801D1AFC244BDEBD1274CE415CA476A807CADA8F2C42E8E43E1F41E66DB4C4389814301DEFFD48B24270EF46A1A387EE8F188FAE13A4C4CDD16FB93212D41F7F6FEB48FC9C41771FBFB97"),
				Q:     fromHex("9361B81F5CACD41B174CA3ECE9A6D00C2659025F4E971AD576C011EF"),
				G:     fromHex("85433986A2AD22D6966D09ADC7FEA96C819F3EA05D48BB4F6DA7320338C1F15FCA3E0A0997E0F3E534147560B3BF001364080E5EFFEB22D741BB6B847E510EBC5760E7DB680D4B9D5BA056C67FECFD43E5BA603BE1F45E033DC54DF46BA15BA1DB7B03FC8622CF8D7FF722790ADB1A3C7A6F3C6A45BAFCD4B334E37E542A07E8981B1A9B662287B79EC23503DEECE39323EF41113B1CE7B6B1F97DD616CEFBEB7E6E6DA548E5707D51C0B30147D280284E68E939DC3B3F372BDD8DBAE6E81E6D81C311FE425D21D9911FC62D9FC9F75C692E93C035A80092E6FE1C9B4EDFE3EDBA2BA8B73AA981F134A1994E70412ED1342207F991610EF9CA9739FCB322F324"),
				Sizes: L2048N224WithSHA224,
			},
			Y: fromHex("57222DEB1FF792B0E14F4DB4499D4A4F668E6407A85D69E0EF3E9063FC1B637F87C9A5FB8CF304D34C33B5B8C87486DC42BC98B79F754774CF6D79D0D90076B56B4C1E5E93C9AFAF755518C111C9DBD6FC954CE02FD5CCC158DB89A5E96142A6F8C271C52D1F5DE033832AFFC44F2606BCB4DC44F7C882C51D7127D1D157D689780BB2C833C196C36F20F27E5B9C205A33FF225B4A104EB6D2EB9DA09F2724B9D30025F8B344E7F77B80884BE5EB7B71D4EEB6EDF105C3CA12AD3410471B246474FBE697C395256D1BA77277E62068B6827E02FD1883C399F562FBE76C49B2D6FAD25C5AF66D1204F9E64FAD797F57DFD6647C2D7BD70CC848744FD490B92A1"),
		},
		X: fromHex("B5D1ADCEA743768BF532EB0A98FEEEB4B80E8FF40FE508DDE9449754"),
	}

	testSignAndVerify(t, 0, &priv)
}

func TestSignAndVerifyWithBadPublicKey(t *testing.T) {
	pub := PublicKey{
		Parameters: Parameters{
			P: fromHex("99811DA76C8218A64F16C765831F140AA833095E3D3126DAC600CAAE8BDDC68E364AB88DDD4AFC56BFFADF17E76DA84C515D41B8A291CF536CB7E087060EC6CEEFE80D1B58A33108C35FD13E897B7B88B51BE194BD693DA5754EC008EBC712C96A4A3BC24B67AABFD2FD9DA28FA1F9EC8032A8E96F6B89AC2AC941AB66E83B8E1BEC0DEE9241110003071BE1B028FC29C7DD046E829D43046014D1BF30FDF2C68C4F60CBE42DCC1E83A9A3E0F9E745BADA12BC7629E801D1AFC244BDEBD1274CE415CA476A807CADA8F2C42E8E43E1F41E66DB4C4389814301DEFFD48B24270EF46A1A387EE8F188FAE13A4C4CDD16FB93212D41F7F6FEB48FC9C41771FBFB97"),
			Q: fromHex("FA"),
			G: fromHex("85433986A2AD22D6966D09ADC7FEA96C819F3EA05D48BB4F6DA7320338C1F15FCA3E0A0997E0F3E534147560B3BF001364080E5EFFEB22D741BB6B847E510EBC5760E7DB680D4B9D5BA056C67FECFD43E5BA603BE1F45E033DC54DF46BA15BA1DB7B03FC8622CF8D7FF722790ADB1A3C7A6F3C6A45BAFCD4B334E37E542A07E8981B1A9B662287B79EC23503DEECE39323EF41113B1CE7B6B1F97DD616CEFBEB7E6E6DA548E5707D51C0B30147D280284E68E939DC3B3F372BDD8DBAE6E81E6D81C311FE425D21D9911FC62D9FC9F75C692E93C035A80092E6FE1C9B4EDFE3EDBA2BA8B73AA981F134A1994E70412ED1342207F991610EF9CA9739FCB322F324"),
		},
		Y: fromHex("57222DEB1FF792B0E14F4DB4499D4A4F668E6407A85D69E0EF3E9063FC1B637F87C9A5FB8CF304D34C33B5B8C87486DC42BC98B79F754774CF6D79D0D90076B56B4C1E5E93C9AFAF755518C111C9DBD6FC954CE02FD5CCC158DB89A5E96142A6F8C271C52D1F5DE033832AFFC44F2606BCB4DC44F7C882C51D7127D1D157D689780BB2C833C196C36F20F27E5B9C205A33FF225B4A104EB6D2EB9DA09F2724B9D30025F8B344E7F77B80884BE5EB7B71D4EEB6EDF105C3CA12AD3410471B246474FBE697C395256D1BA77277E62068B6827E02FD1883C399F562FBE76C49B2D6FAD25C5AF66D1204F9E64FAD797F57DFD6647C2D7BD70CC848744FD490B92A1"),
	}

	ok, _ := Verify(&pub, bytes.NewReader([]byte("testing")), fromHex("2"), fromHex("4"))
	if ok {
		t.Errorf("Verify unexpected success with non-existent mod inverse of Q")
	}
}

func TestSigningWithDegenerateKeys(t *testing.T) {
	// Signing with degenerate private keys should not cause an infinite
	// loop.
	badKeys := []struct {
		p, q, g, y, x string
	}{
		{"00", "01", "00", "00", "00"},
		{"01", "ff", "00", "00", "00"},
	}

	for i, test := range badKeys {
		priv := PrivateKey{
			PublicKey: PublicKey{
				Parameters: Parameters{
					P: fromHex(test.p),
					Q: fromHex(test.q),
					G: fromHex(test.g),
				},
				Y: fromHex(test.y),
			},
			X: fromHex(test.x),
		}

		data := []byte("testing")
		if _, _, err := Sign(rand.Reader, &priv, bytes.NewReader(data)); err == nil {
			t.Errorf("#%d: unexpected success", i)
		}
	}
}
